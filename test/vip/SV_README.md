# Open-source ACE verification IP

These IPs target the AXI4 ACE specification, specifically the issue E.

## Limitations
- Does not test exclusive access
- Does not test cache maintenance operations
- Does not test barriers
- Does not test DVMs
- Does not support snoop filtering
- Does not support ACE-Lite

## Transaction converage
The cache model currently generates the following ACE transactions:
  - ReadUnique
  - ReadShared
  - CleanUnique
  - WriteUnique
  - WriteLineUnique
  - WriteBack

## ACE

### ace_agent
Collects all ace related components.

### ace_beat_types
Collects the datatypes for ACE transactions.

### ace_driver
Component which receives ACE transactions in a mailbox (AW, W and AR channels) and drives the ACE interface signals accordingly. It also drives the signals to receive responses (R and B), but does not collect them.

### ace_monitor
Component which monitors the ACE interface signals and detects received B or R responses. Puts the responses in a mailbox.

### ace_sequencer
Contains the abstract class `ace_sequencer` and two classes `ace_rand_sequencer` and `ace_mbox_sequencer` which extend the abstract class. In this project, `ace_mbox_sequencer` is used, but the other one can also be used for a standalone testbench without coherency-checking.

`ace_mbox_sequencer` receives ACE transactions in a mailbox and sends them to `ace_driver`.

## Snoop

### snoop_agent
Collects all snoop-channel related components.

### snoop_beat_types
Collects the datatypes for snoop transactions, i.e. AC/CD/CR

### snoop_driver
Component which receives snoop responses in a mailbox and drives the snoop interface signals (CR and CD). It also drives the ready signal of the AC channel, toggling it randomly.

### snoop_monitor
Component which monitors the snoop interface's AC channel and puts the received transaction into a mailbox.

### snoop_sequencer
Receives AC transactions in a mailbox and converts them into cache requests. Requests the cache for data. Receives the response, and puts the CR and possible CD responses into a mailbox.

This class also contains functions to generate a random response instead of requesting the cache.

## Cache

### cache_beat_types
Collects the datatypes for cache and memory transactions. These are in custom format.

### cache_scoreboard
Contains the behavioral model for an n-way set-associative cache. It has two sources of requests - cache requests from `cache_sequencer` and snoop requests from `snoop_sequencer`. These are not arbitrated in any way, as it is an interconnect requirement that a cache line must not see a snoop to the same cache line during an outstanding transaction.

Large part of the cache model is to generate correct ACE transactions for a specific situation. For example, a non-cached write generates a WriteUnique transaction, while a cached write would generate a ReadUnique transaction for the allocation of the cache line.

The cache can be initialized from a file. The Python part of this framework handles the generation of a randomized, cache-coherent initial state.

All cache modifications are logged in a file for both debugging purposes and to reconstruct it later in Python domain for coherency check.

### cache_sequencer
Generates cache requests from a transaction file which is generated by the Python scripts.

### cache_top_agent
Collects all verification components. This is the module to instantiate in the testbench.

### mem_logger
Connects to `axi_sim_mem`. Logs changes in memory to a file for both debugging purposes and to reconstruct the state in Python.

### mem_sequencer
Receives memory requests in a mailbox and converts them into ACE requests. Puts them into a mailbox.
